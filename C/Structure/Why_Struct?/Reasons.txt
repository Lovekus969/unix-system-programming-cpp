In large real-time systems (Google servers, databases, OS kernels, self-driving car systems, telecom systems), you must keep data organized, consistent, and safe.

If you pass too many individual parameters around instead of grouping them in a struct:

Why using STRUCT prevents crashes
  1. Struct groups related data together
  Passing 10 separate arguments increases the chance of an error.

2. Struct ensures memory layout is consistent

  Real-time systems depend on fixed memory layout.
  The layout of a struct is predictable, well-aligned, and optimized by the compiler.
  If your system expects a specific memory format (e.g., a network packet, sensor data), and you pass random parameters separately, you can corrupt the memory.

3. Structs avoid stack overflow

  Passing too many arguments uses too much stack.
  Structs use one pointer, so memory usage stays small and constant.

4. Structs allow atomic updates

  In multi-threaded systems:
  Updating one field at a time is dangerous.
  Updating the entire struct at once is safe.

5. Structs make APIs stable

  Large companies like Google maintain APIs used by thousands of developers.
  If they passed 8 parameters and then needed to add 2 more → all code breaks.
  But with structs:
    You can add new fields without breaking old code.


REAL-TIME EXAMPLE (GOOGLE-LEVEL):
  Google Search Backend: Handling a Search Request
  Every time someone types something on Google, billions of requests flow across thousands of servers.
  Google internally uses functions like:

                                               handleSearch(query, user_id, region, device, language, timestamp);

    Now imagine this is deployed across:
    
    300,000 servers
    
    hundreds of microservices
    
    global data centers

PROBLEM: Passing individual parameters is dangerous
Say Google decides to add 1 new field: 
                                                            int safe_mode;

So  the function be look like 
                                             handleSearch(query, user_id, region, device, language, timestamp, safe_mode);              // X  safe_mode has been added  X

But the new function expects 7 parameters.

RESULT?

          Servers crash or behave unpredictably
          Wrong values shift into wrong fields
          Memory corruption happens
          Requests get misinterpreted
          The entire search service can freeze or misroute traffic
Example of what shifts:
| Old Parameter | New Meaning after function signature changes |
| ------------- | -------------------------------------------- |
| timestamp     | becomes `safe_mode` accidentally             |
| safe_mode     | becomes garbage value in memory              |


Cheackout file curruption.c 

WHY THIS BREAKS IN REAL SYSTEMS
    When calling the new function but passing only old arguments:
            The last parameter (safe_mode) is taken from random leftover stack memory.
    
    Could be:
    
            a huge negative value
            0 or 1 incorrectly
            a memory pointer
            corrupted bytes

VERSION 2 – SAFE DESIGN (Using STRUCT)

cheack out the file Struct_Non_Corruption 
