What is a Structure in C?
A structure is a user-defined data type that allows you to combine data items of different kinds. Structures are used to represent a record of related information.

Why useful?
    Organizes data neatly
    Used in system-level programs (file system, networking, OS)
    Foundation for linked lists, trees, queues, etc.

Typedef
    Definition:
    typedef creates a nickname/alias for a data type.

Unions
    Definition:
    A union is like a structure, but all members share the same memory.
. Bitwise Operators

Used to manipulate individual bits of data.
    
    Operators:
    
                    & AND
                    | OR
                    ^ XOR
                    ~ NOT
                    << left shift
                    >> right shift
    
    Why useful?
    
                    Hardware programming
                    Flags and masks
                    Permissions
                    Compression
                    Fast arithmetic
Enumerations (enum)
        Definition:
        A set of named integer constants.

Why does a structure end with a semicolon?
    Every structure definition must end with ; because the C syntax treats it like declaring a new type.

struct employee {
    char firstName[20];
    char lastName[20];
    int age;
    double hourlySalary;
};

Operations That Can Be Performed on Structures (1 of 3)
.     Assigning one struct variable to another
    can directly assign one struct variable to another if they are the same type.
example:=>> 
struct Card {
    const char *face;
    const char *suit;
};

struct Card c1 = {"Ace", "Spades"};
struct Card c2;

c2 = c1;  // ✔ allowed — copies all members

❗Important:

2. Taking the address (&) of a struct variable
    You can take the address of a struct just like any normal variable.
    If a structure contains pointers, only the pointer address is copied, not the actual data.

Example: 
    c2.face = c1.face;  // same char* pointer, not new memory

Using sizeof() to get struct size
    can check how much memory the entire structure uses.

Example:
    printf("Size = %zu bytes\n", sizeof(struct Card));

Size depends on:
        data types inside
        padding/alignment rules
Summary 
| Operation                    | Allowed?      | Notes                       |
| ---------------------------- | ------------- | --------------------------- |
| Assign one struct to another | ✔ Yes         | Shallow copy                |
| Assign pointer members       | ✔ Yes         | Only pointer address copied |
| Take address `&struct`       | ✔ Yes         | Use pointer with `->`       |
| Access members with `.`      | ✔ Yes         | For normal variables        |
| Access members with `->`     | ✔ Yes         | For pointers                |
| Use `sizeof(struct)`         | ✔ Yes         | Finds total size            |
| Zero-initialize with `{}`    | ✔ Very useful | Sets all members to 0/NULL  |

We are going to see a clear explanation of  why structure objects cannot be compared directly in C, along with what padding, alignment, and holes mean.

Structure members may not be stored in continuous memory due to padding and alignment rules used by the CPU.
Because of padding:

    Two structs with identical member values may have different binary memory layouts.
    Comparing raw bytes would give incorrect results.

What Is Padding? (The “Holes”)

        Modern CPUs require data to be aligned to certain byte boundaries for fast access.
        Example: int usually needs to start at a 4-byte boundary.
        
        So consider:
        
        struct example {
            char c;   // 1 byte
            int i;    // 4 bytes
        };
        
        
        Memory layout with padding on a 4-byte aligned machine:
